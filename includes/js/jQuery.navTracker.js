// Generated by CoffeeScript 1.4.0

/*
 * jQuery.navTracker
 * v0.2
 * last updated 2013-01-15
 *
 * A simple plugin to track changes in navigation and update location.hash
 *
 * Author: Ben Saufley
 *     http://bensaufley.com
 *
 * Based on jQuery plugin boilerplate by Jonathan Nicol @f6design
*/


(function() {

  (function($) {
    var Plugin, pluginName;
    pluginName = 'navTracker';
    Plugin = function(element, options) {
      var $el, checkTimer, current, destroy, el, hook, init, option, scrollChecker, scrollPos, updateHash;
      el = element;
      $el = $(element);
      scrollPos = null;
      checkTimer = null;
      current = null;
      options = $.extend({}, $.fn[pluginName].defaults, options);
      init = function() {
        if (location.hash) {
          if ($(location.hash)) {
            $('html,body').scrollTop($(location.hash).offset().top);
          }
        }
        scrollChecker();
        return hook('onInit');
      };
      destroy = function() {
        clearTimeout(checkTimer);
        $el.find("." + options.selectedClass).removeClass(options.selectedClass);
        return hook('onDestroy');
      };
      scrollChecker = function() {
        var $e, elems, offsets, result, scrolledTo, st, x, _i, _len;
        if ($(window).scrollTop() !== scrollPos) {
          scrollPos = $(window).scrollTop();
          st = scrollPos + options.offset;
          offsets = [0];
          elems = {
            0: options.top
          };
          if (st > options.offset) {
            $el.find('a[href^="#"]').each(function(i) {
              var $e, $loc, hrf, offset;
              $e = $(this);
              hrf = $e.attr('href').replace(/^#/, '');
              if (/^\s*$/.test(hrf) !== true) {
                $loc = $('#' + hrf);
                offset = $loc.offset();
                offsets[i] = offset.top;
                return elems[offset.top] = hrf;
              }
            });
            offsets.sort(function(a, b) {
              return b - a;
            });
          }
          result = 0;
          for (_i = 0, _len = offsets.length; _i < _len; _i++) {
            x = offsets[_i];
            if (x <= st) {
              result = x;
              break;
            }
          }
          scrolledTo = elems[result] || options.top;
          if (scrolledTo !== current) {
            $e = $el.find("a[href=\"#" + scrolledTo + "\"]");
            $el.find("." + options.selectedClass).removeClass(options.selectedClass);
            $e.addClass(options.selectedClass);
            updateHash(scrolledTo);
            options.top = current;
            hook('onChange');
          }
        }
        return checkTimer = setTimeout(scrollChecker, options.refreshRate);
      };
      updateHash = function(hash) {
        var fx, node;
        node = $("#" + hash);
        if (node.length) {
          node.attr('id', '');
          fx = $('<div></div>').css({
            position: 'absolute',
            visibility: 'hidden',
            top: $(document).scrollTop() + 'px'
          }).attr('id', hash).appendTo(document.body);
        }
        document.location.hash = hash;
        if (node.length) {
          fx.remove();
          return node.attr('id', hash);
        }
      };
      option = function(key, val) {
        if (val) {
          return options[key] = val;
        } else {
          return options[key];
        }
      };
      hook = function(hookName) {
        if (options[hookName] !== void 0) {
          return options[hookName].call(el, current);
        }
      };
      init();
      return {
        current: current,
        option: option,
        destroy: destroy
      };
    };
    $.fn[pluginName] = function(options) {
      var args, methodName, returnVal;
      if (typeof arguments[0] === 'string') {
        methodName = arguments[0];
        args = Array.prototype.slice.call(arguments, 1);
        returnVal = null;
        this.each(function() {
          if ($.data(this, "plugin_" + pluginName) && typeof $.data(this, "plugin_" + pluginName)[methodName] === 'function') {
            return (returnVal = $.data(this, "plugin_" + pluginName)[methodName].apply(this, args));
          } else {
            throw new Error("Method " + methodName + " does not exist on jQuery." + pluginName);
          }
        });
        if (returnVal !== void 0) {
          return returnVal;
        } else {
          return this;
        }
      } else if (typeof options === "object" || !options) {
        return this.each(function() {
          if (!$.data(this, 'plugin_' + pluginName)) {
            return $.data(this, "plugin_" + pluginName, new Plugin(this, options));
          }
        });
      }
    };
    return $.fn[pluginName].defaults = {
      selectedClass: 'selected',
      refreshRate: 100,
      offset: 0,
      top: 'top',
      onInit: function() {},
      onChange: function() {},
      onDestroy: function() {}
    };
  })(jQuery);

}).call(this);
